'use strict';

// not allow {{x:{y:1}}}
// or use complex parser
// const util = require('util');

var babylon = require('babylon');
var assign = require('object-assign');
var traverse = require('babel-traverse');
var generate = require('babel-generator');
var t = require('babel-types');

t = t['default'] || t;
babylon = babylon['default'] || babylon;
traverse = traverse['default'] || traverse;
generate = generate['default'] || generate;

var expressionTagReg = /\{\{([^}]+)\}\}/g;
var fullExpressionTagReg = /^\{\{([^}]+)\}\}$/;
var spreadReg = /^\.\.\.[\w$_]/;
var objReg = /^[\w$_](?:[\w$_\d\s]+)?:/;
var es2015ObjReg = /^[\w$_](?:[\w$_\d\s]+)?,/;

function isObject(str_) {
  var str = str_.trim();
  return str.match(spreadReg) || str.match(objReg) || str.match(es2015ObjReg);
}

var babylonConfig = {
  plugins: ['objectRestSpread']
};

function findScope(scope, name) {
  if (scope) {
    return scope.some(function (s) {
      return s[name];
    });
  }
  return false;
}

function escapeString(str) {
  return str.replace(/[\\']/g, '\\$&');
}

var refVisitor = {
  noScope: 1,

  ReferencedIdentifier: function ReferencedIdentifier(path) {
    var node = path.node;

    if (!node.__rmlSkipped && !findScope(this.rmlScope, node.name)) {
      node.name = 'data.' + node.name;
    }
  }
};

// TODO. use https://www.npmjs.com/package/babel-plugin-transform-optional-chaining
var looseDataVisitor = assign({
  MemberExpression: function MemberExpression(path) {
    var parent = path.parent,
        node = path.node;

    var parentType = parent && parent.type;
    // do not transform function call
    // skip call callee x[y.q]
    if (
    // root member node
    parentType !== 'MemberExpression' &&
    // skip call callee x[y.q]
    parent.callee !== node) {
      // allow {{x.y.z}} even x is undefined
      var members = [node];
      var root = node.object;

      while (root.type === 'MemberExpression') {
        members.push(root);
        root = root.object;
      }

      members.reverse();
      var args = [root];

      if (root.type === 'ThisExpression') {
        args.pop();
        args.push(members.shift());
      }

      if (!members.length) {
        return;
      }

      members.forEach(function (m) {
        // x[y]
        if (m.computed) {
          args.push(m.property);
        } else {
          // x.y
          args.push(t.stringLiteral(m.property.name));
        }
      });

      var newNode = t.callExpression(t.identifier('$getLooseDataMember'), args);
      newNode.callee.__rmlSkipped = 1;
      // will process a.v of x.y[a.v]
      path.replaceWith(newNode);
    }
  }
}, refVisitor);

function transformCode(code_, rmlScope, config) {
  var visitor = config.strictDataMember === false ? looseDataVisitor : refVisitor;

  var codeStr = code_;

  if (config.forceObject || isObject(codeStr)) {
    codeStr = '{' + codeStr + '}';
  }

  var ast = babylon.parse('(' + codeStr + ')', babylonConfig);
  // if (ast.type === 'Identifier') {
  //   ast.name = `data.${ast.name}`;
  // } else {
  traverse(ast, visitor, undefined, { rmlScope: rmlScope });
  // }

  var _generate = generate(ast),
      code = _generate.code;

  if (code.charAt(code.length - 1) === ';') {
    code = code.slice(0, -1);
  }
  return '(' + code + ')';
}

function transformExpressionByPart(str_, scope, config) {
  if (typeof str_ !== 'string') {
    return [str_];
  }
  var str = str_.trim();
  if (!str.match(expressionTagReg)) {
    return ['\'' + escapeString(str_) + '\''];
  }
  var match = str.match(fullExpressionTagReg);
  if (match) {
    return [transformCode(match[1], scope, config)];
  }
  var totalLength = str.length;
  var lastIndex = 0;
  var gen = [];
  /* eslint no-cond-assign:0 */
  while (match = expressionTagReg.exec(str)) {
    var code = match[1];
    if (match.index !== lastIndex) {
      gen.push('\'' + escapeString(str.slice(lastIndex, match.index)) + '\'');
    }
    gen.push(transformCode(code, scope, config));
    lastIndex = expressionTagReg.lastIndex;
  }

  if (lastIndex < totalLength) {
    gen.push('\'' + escapeString(str.slice(lastIndex)) + '\'');
  }
  return gen;
}

export function transformExpression(str_, scope) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var ret = transformExpressionByPart(str_, scope, config);
  if ('text' in config) {
    return ret.length > 1 ? '[' + ret.join(', ') + ']' : ret[0];
  }
  return ret.join(' + ');
}

export function hasExpression(str) {
  return str.match(expressionTagReg);
}